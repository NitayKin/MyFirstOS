x86:
GENERAL:
(especially important in real mode)
there is a lot of history with the architectures, so sometimes 8086/80286/80386/80486 ( history : then pentium, celeron and corei2 ) assembly wont be compatible with each other on some instructions.

--------------------------------------------------------------------

REAL MODE:
first, we get into real mode ( real = memory is the real number ). 16 bit memory(extended with segments) and registers.
the BIOS loads the first sector in memory region 0x7c00. for referencal jumping ( to labels for example), we need to tell the assembler that : [ org 0x7c00 ]
the only functions we can use are the ones the BIOS gives us.
in real mode, the address of the memory we want to go is calculated using segment registers:

CS = code segment
DS = data segment
SS = stack segment
ES = programmer segment

all of the above are 16 bit.
so now the memory location looks like this:

segment:offset (its called the logical adrress, which after the calculation becomes physical address).

and we calculate it as follows:
real address: segment*16+offset (shift 4 the segment and add offset).
important! some instructions use ES implicity!

--------------------------------------------------------------------

PROTECTED MODE:
32bit environment (which means memory 32 and registers 32), suitable for c compilation.
no bios anymore. new segment registers fs and gs. gst and segment code protection.
here start the GDT -Global descriptor table - which is a table saving the base and offset of code\data segments. now, the segment registers will hold the offest in THE GDT TABLE for their apripriate role.
we pass the gdt_descriptor to tthe cpu - which is just a struct holding the start address of the gdt and its length.

--------------------------------------------------------------------

INTERRUPTS(idt table):
There are 3 sources or types of interrupts:
Hardware interrupts - comes from hardware devices like keyboard or network card. (PIC)
Software interrupts - generated by the software int instruction. Before introducing SYSENTER/SYSEXIT system calls invocation was implemented via the software interrupt int $0x80.
Exceptions - generated by CPU itself in response to some error like “divide by zero” or “page fault”.

0-19 are non-maskable interrupts, 20-31 should be reserved by Intel, 32-127 are the external interrupts (IRQ - handled with the PIC device).
the function that being called in response to interrupt is called ISR = interrupt service routine.
IRQs 0 to 7 are set to interrupts 08h to 0Fh, and IRQs 8 to 15 are set to interrupts 70h to 77h.
The OS is supposed to handle the interrupt by talking to the X, via in and out instructions (which goes via the PIC).

In protected mode, the IRQs 0 to 7 conflict with the CPU exception which are reserved by Intel up until 0x1F. (It was an IBM design mistake.)

When IRET is executed, it expects the stack to have the following (the HW put them on stack when interrupt generated):
SS
ESP
EFLAGS
CS
EIP

--------------------------------------------------------------------

MEMORY MANAGMENT(segmentation/paging):
How it works?
So, to access a memory, first the program needs to access a segment. To do this a segment selector is loaded into a segment register and then a Global or Local Descriptor table (depending of field on the segment selector). This is the reason of the fully memory address be SEGMENT REGISTER: ADDRESS , like CS:ADDRESS -> 001B:0044BF7A. Now the OS goes to the G/LDT and (using the index field of the segment selector) finds the segment descriptor of the address trying to access. Then it checks if the segment if present, the protection and if everything is ok it goes to the address stated on the “base field” (of the descriptor) + the address offset . If paging is not enabled, the system goes directly into the real memory, but with paging on the address is treated as a virtual address and it goes to the Page directory. The base address + the offset are called Linear Address and will be interpreted as 3 fields: Directory+Page+offset. So on the Directory page, it will search for the directory entry specified on the “directory” field of the linear address, this entry points to the page table and the field “page” of the linear address is used to find the page, this entry points to a frame page and the offset is used to find the exactly address that the program want to access.

Modern OSes "do not use" segmentation. Its in quotes because they use 4 segments: Kernel Code Segment, Kernel Data Segment, User Code Segment and User Data Segment. What does it means is that all user's processes have the same code and data segments (so the same segment selector). The segments only change when going from user to kernel. So, all the path explained on the section 3.3. occurs, but they use the same segments and, since the page tables are individual per process, a page fault is difficult to happen.

--------------------------------------------------------------------

PAGING:
Paging is achieved through the use of the Memory Management Unit (MMU). On the x86, the MMU maps memory through a series of tables, two to be exact. They are the paging directory (PD), and the paging table (PT).
Both tables contain 1024 4-byte entries, making them 4 KiB each. In the page directory, each entry points to a page table. In the page table, each entry points to a 4 KiB physical page frame. Additionally, each entry has bits controlling access protection and caching features of the structure to which it points. 
Translation of a virtual address into a physical address first involves dividing the virtual address into three parts: the most significant 10 bits (bits 22-31) specify the index of the page directory entry, the next 10 bits (bits 12-21) specify the index of the page table entry, and the least significant 12 bits (bits 0-11) specify the page offset.

Page Table Entry (PTE):
    Bit 0 (P): Present flag
        0: Page is not in memory
        1: Page is present (in memory)
    Bit 1 (R/W): Read/Write flag
        0: Page is read only
        1: Page is writable
    Bit 2 (U/S):User mode/Supervisor mode flag
        0: Page is kernel (supervisor) mode
        1: Page is user mode. Cannot read or write supervisor pages
    Bits 3-4 (RSVD): Reserved by Intel
    Bit 5 (A): Access flag. Set by processor
        0: Page has not been accessed
        1: Page has been accessed
    Bit 6 (D): Dirty flag. Set by processor
        0: Page has not been written to
        1: Page has been written to
    Bits 7-8 (RSVD): Reserved
    Bits 9-11 (AVAIL): Available for use
    Bits 12-31 (FRAME): Frame address - this page table manages the FRAME*4kb physical memory location ( for example, 0x00000 means 0-4kb physical memory,0x00001 means 4kb-8kb).
page table has 1024 of those entries, and therefor can rule 4MB (1024*4KB = 4MB).

Page Directory Entry:
    Bit 0 (P): Present flag
        0: Page table is not in memory
        1: Page table is present (in memory)
    Bit 1 (R/W): Read/Write flag
        0: Page table is read only
        1: Page table is writable
    Bit 2 (U/S):User mode/Supervisor mode flag
        0: Page table is kernel (supervisor) mode
        1: Page table is user mode. Cannot read or write supervisor pages
    Bit 3 (PWT):Write-through flag
        0: Write back caching is enabled
        1: Write through caching is enabled
    Bit 4 (PCD):Cache disabled
        0: Page table will not be cached
        1: Page table will be cached
    Bit 5 (A): Access flag. Set by processor
        0: Page has not been accessed
        1: Page has been accessed
    Bit 6 (D): Reserved by Intel
    Bit 7 (PS): Page Size
        0: 4 KB pages
        1: 4 MB pages
    Bit 8 (G): Global Page (Ignored)
    Bits 9-11 (AVAIL): Available for use
    Bits 12-31 (FRAME): Page Table Base address - the address of the page table this directory entry manages.
page table has 1024 of those entries, and therefor can rule 1024 page tables, ranging all 4GB of memory ( 1024*4MG = 4GB ).

This is the format of a x86 virtual address:

AAAAAAAAAA         BBBBBBBBBB        CCCCCCCCCCCC
directory index    page table index  offset into page


--------------------------------------------------------------------

USER\KERNEL:
becuase we know CS ( and the rest segment register ) are always upped by 0x08 ( becuase gdt is alligned that way ), we can utilize the 3 lsb bits for:
DPL:
The Descriptor Protection Level (DPL) is the protection level of a segment descriptor. For example, our kernels code and data segments DPL are 0 for ring 0 access.
RPL:
The Requested Protection Level (RPL) allows software to override the CPL to select a new protection level. This is what allows software to request changes to other protection levels, such as ring 0 to ring 3. The RPL is stored in bits 0 and 1 of a descriptor selector.
Wait, what? Remember that a segment selector is just an offset into the GDT. So, for example, 0x8 bytes was the offset for our ring 0 code descriptor. 0x10 was the offset of our data selector. 0x8 and 0x10 are segment selectors. GDT entries are all 8 bytes, so the value of a segment selector will always be a multiple of 8: 8, 16, 24, 32 etc. 8, in binary, is 1000. This means, with any value of a segment selector, the low three bits are zero.
The RPL is stored in the low two bits of the segment selector. So, if our segment selector is 0x8, the RPL is 0. If its 0xb (0x8 but with first two bits set, binary 1011 instead of 1000) the RPL is 3. This is required; this is how our software can switch to user mode.
CPL:
The Current Protection Level (CPL) is the protection level of the currently executing program. The CPL is stored in bits 0 and 1 of SS and CS.

--------------------------------------------------------------------

TSS(task state segment):
The X86 architecture has support for hardware-assisted task switching by way of a list of Task State Segments (TSS). In this tutorial set we have (like BSD, linux and most x86 operating systems) decided against using it and opted instead for a software based solution. The main reason for this is that hardware task switching is actually not much faster than software, and software task switching is far more portable between platforms.
With that said, the way the x86 architecture is designed we have no choice but to use at least one TSS. This is because when a program in user mode (ring 3) executes a system call (software interrupt) the processor automatically looks in the current TSS and sets the stack segment (SS) and stack pointer (ESP) to what it finds in the SS0 and ESP0 fields ('0' because it's switching to ring 0) - in essence this switches from the user's stack to your kernel stack.
the TSS also resides in the GDT table.

